Topic 1: introduction to MongoDB
To understand MongoDB, we first need to understand the problem it solves.

1. SQL(The old way) => for decades, databases were like excel spreadsheets. you had Tables(like "students"), Columns(Name, Age, Marks), and Rows (The actual data).

. The problem => it is rigid. if you define a table with 3 Columns, you cannot suddenly add a 4th Column for just one student. you have to change the entire table structure.

2. MongoDB(The NoSQL way) => MongoDB is a NoSQL(Not only SQL) database. instead of Tables, it uses Documents.

. The Solution => it is flexible. A Document is just a JSON object. one student can have 3 fields(name, age, marks) and the next student can have 5 fields (name, age , hobbies, address, phone). MongoDB doesn't care.

Why is it perfect for Node.js?
=> Node.js code uses JSON Objects.
=> MongoDB stores JSON-like Documents(technically BSON).
=> this means you don't have to convert data. you just save you javaScript directly into the database

Topic 2: MongoDB database and shell installation => this is the practical part. you can't write code until the database engine is running on your laptop.

Note: MongoDB has split its tools into three parts. you need to install them in this order.

Part A: Install the Server (The engine)
This is the actual database that runs in background.

1. got to https://www.mongodb.com/try/download/community
2. select
    . Version: Latest (e.g., 7.x or 8.x)
    . Platform: Windows x64 (MSI)

3. click download and run the installer

4. CRITICAL STEP  during installation
    . select "complete" setup.
    . You will see a screen "Service Configuration". Ensure "Install MongoDB as a Service" is CHECKED. (This ensures it runs automatically).
    . You will see a checkbox for "Install MongoDB Compass". CHECK this. (Compass is a GUI tool, like a file explorer for your data).

part B: install the shell (mongosh)
The "Shell" is the command-line tool you use to type commands like db.users.find(). It is now a separate download.

    1. Go to the https://www.mongodb.com/try/download/shell
    2. Download the ZIP package for Windows.
    3. Extract the ZIP. You will find a file named mongosh.exe inside the bin folder.
    4. setup.
        . Copy mongosh.exe
        . Paste it into your MongoDB Server folder (usually C:\Program Files\MongoDB\Server\7.0\bin). This keeps everything in one place.
    5. Add to path(optional but recommended)
        . Copy the path to that bin folder.
        . Search Windows for "Edit the system environment variables" -> Environment Variables.
        . Select Path -> Edit -> New -> Paste the path.
        . This lets you type mongosh in any terminal window.

part C: Verify installation => lets make sure it's works before moving to the next Topic
1. Open your Command Prompt (cmd) or VS Code terminal.
2. Type: mongosh and press Enter.
3. Success: You should see a prompt that looks like test>. This means you are connected to your local database!
4. Type exit to quit.

Topic 3: MongoDB Terminalogy => database, collection, Document and field

To understand these, it helps to compare them to a traditional SQL database (like MySQL or tables in Excel), which you might have seen before.

1. database

. Definition => The top-level container. it holds all your data for a specific application.
. Analogy: This is like the Workbook file in Excel (e.g., CollegeData.xlsx).
. In MongoDB: You can have multiple databases on one server (e.g., one for your "Chat App" and another for your "School Project").

2. collection

. Definition: A group of similar records.
. Analogy: This is like a single Sheet or Tab inside your Excel workbook (e.g., a "Students" tab).
. In MongoDB: A database contains collections. For example, your CollegeData database might have a students collection and a teachers collection.
. Key Difference: In SQL, this is called a Table.

3. Document

. Definition: A single record of data.
. Analogy: This is like a single Row in your Excel sheet (e.g., Row 2, which contains all of "Ashutosh's" data).
. In MongoDB: A collection contains documents.
. Key Difference: In SQL, this is called a Row. In MongoDB, it is a JSON object.

4. field

. Definition: A specific piece of data inside a document.
. Analogy: This is like a Column Header or a specific Cell (e.g., "Name", "Age", "Email").
. In MongoDB: A document contains fields.
. Key Difference: In SQL, this is called a Column.

Visualizing the Hierarchy

 1. DATABASE: "CollegeDB"
    |
    +-- 2. COLLECTION: "students"
        |
        +-- 3. DOCUMENT (Student 1)
        |   {
        |      "name": "Sunny",      <-- 4. FIELD: "name"
        |      "age": 21,               <-- 4. FIELD: "age"
        |      "course": "CSE"          <-- 4. FIELD: "course"
        |   },
        |
        +-- 3. DOCUMENT (Student 2)
            {
               "name": "Rahul",
               "age": 22
            }

Comparision Table

SQL(traditional)  MongoDB(NoSQL)
database          database
Table             collection
Row               Document
Column            field

Topic 4: MongoDB Shell commands
=> in MongoDB, you don't need to "officially" create things before you use them. they are created automatically when you first save data.

1. create(switch) database 
Command: use <database_name>
=> in SQL, you must run CREATE DATABASE. in MongoDB, you just tell the cell "i want to use the "college" database". if it doesn't exist, MongoDB waits until you save data to actually create it.

Type this => use college
output => switched to db college
your propmt should now change to college>

2. create collection and create documents(insert)
Command: db.<collection_name>.insertOne(<document>)
=> We will create a collection named students and add your first document to it.

db.students.insertOne({ name: "Sunny", age: 21, course: "CSE" })

=> you will see a JSON object like :
{
  "acknowledged": true,
  "insertedId": ObjectId("656...")
}

=> acknowledged : true means it worked
=> insertedId : this is the unique '_id' MongoDB automatically generates for you 


3. Read Data (find)

Command: db.<collection_name>.find()
now let's see what is inside our collection

type this : db.students.find()

output 
[
  {
    "_id": ObjectId("..."),
    "name": "Ashutosh",
    "age": 21,
    "course": "CSE"
  }
]

This lists all Documents in collection

4. data manipulation - update

Command: db.<collection_name>.updateOne(<filter>, <update_action>)

=> we need to update the document where 'name' is 'Sunny'. we use '$set' operator to tell MongoDB exactly which field to change.

db.students.updateOne(
  { name: "Sunny" },
  { $set: { age: 22 } }
)

output:

{
  "acknowledged": true,
  "insertedId": null,
  "matchedCount": 1,
  "modifiedCount": 1,
  "upsertedCount": 0
}

matchedCount: 1: It found 1 student named Sunny.
modifiedCount: 1: It successfully updated 1 document.

Perfect. You are currently at the test> prompt in your terminal. We are going to execute the commands listed in your syllabus one by one.

Topic 4: MongoDB Shell Commands

In MongoDB, you don't need to "officially" create things before you use them. They are created automatically when you first save data.

Type these commands into your terminal as we go.

1. Create (Switch) Database
Command: use <database_name>

In SQL, you must run CREATE DATABASE. In MongoDB, you just tell the shell "I want to use the college database." If it doesn't exist, MongoDB waits until you save data to actually create it.

Type this:

JavaScript

use college
Output: switched to db college

Your prompt should now change to college>.

2. Create Collection & Create Documents (Insert)
Command: db.<collection_name>.insertOne(<document>)

We will create a collection named students and add your first document to it.

Type this:

JavaScript

db.students.insertOne({ name: "Ashutosh", age: 21, course: "CSE" })
Output: You will see a JSON object like:

JSON

{
  "acknowledged": true,
  "insertedId": ObjectId("656...")
}
acknowledged: true means it worked.

insertedId: This is the unique _id MongoDB automatically generated for you.

3. Read Data (Find)
Command: db.<collection_name>.find()

Now, let's see what is inside our collection.

Type this:

JavaScript

db.students.find()
Output:

JSON

[
  {
    "_id": ObjectId("..."),
    "name": "Ashutosh",
    "age": 21,
    "course": "CSE"
  }
]
This lists all documents in the collection.

4. Data Manipulation - Update
Command: db.<collection_name>.updateOne(<filter>, <update_action>)

Let's say Ashutosh had a birthday and turned 22. We need to update the document where name is "Ashutosh". We use the $set operator to tell MongoDB exactly which field to change.

Type this:

JavaScript

db.students.updateOne(
  { name: "Ashutosh" },
  { $set: { age: 22 } }
)
Output:

JSON

{
  "acknowledged": true,
  "insertedId": null,
  "matchedCount": 1,
  "modifiedCount": 1,
  "upsertedCount": 0
}
matchedCount: 1: It found 1 student named Ashutosh.

modifiedCount: 1: It successfully updated 1 document.

Verify it: Type db.students.find() again. You will see "age" is now 22.

Perfect. You are currently at the test> prompt in your terminal. We are going to execute the commands listed in your syllabus one by one.

Topic 4: MongoDB Shell Commands

In MongoDB, you don't need to "officially" create things before you use them. They are created automatically when you first save data.

Type these commands into your terminal as we go.

1. Create (Switch) Database
Command: use <database_name>

In SQL, you must run CREATE DATABASE. In MongoDB, you just tell the shell "I want to use the college database." If it doesn't exist, MongoDB waits until you save data to actually create it.

Type this:

JavaScript

use college
Output: switched to db college

Your prompt should now change to college>.

2. Create Collection & Create Documents (Insert)
Command: db.<collection_name>.insertOne(<document>)

We will create a collection named students and add your first document to it.

Type this:

JavaScript

db.students.insertOne({ name: "Ashutosh", age: 21, course: "CSE" })
Output: You will see a JSON object like:

JSON

{
  "acknowledged": true,
  "insertedId": ObjectId("656...")
}
acknowledged: true means it worked.

insertedId: This is the unique _id MongoDB automatically generated for you.

3. Read Data (Find)
Command: db.<collection_name>.find()

Now, let's see what is inside our collection.

Type this:

JavaScript

db.students.find()
Output:

JSON

[
  {
    "_id": ObjectId("..."),
    "name": "Ashutosh",
    "age": 21,
    "course": "CSE"
  }
]
This lists all documents in the collection.

4. Data Manipulation - Update
Command: db.<collection_name>.updateOne(<filter>, <update_action>)

Let's say Ashutosh had a birthday and turned 22. We need to update the document where name is "Ashutosh". We use the $set operator to tell MongoDB exactly which field to change.

Type this:

JavaScript

db.students.updateOne(
  { name: "Ashutosh" },
  { $set: { age: 22 } }
)
Output:

JSON

{
  "acknowledged": true,
  "insertedId": null,
  "matchedCount": 1,
  "modifiedCount": 1,
  "upsertedCount": 0
}
matchedCount: 1: It found 1 student named Ashutosh.

modifiedCount: 1: It successfully updated 1 document.

Verify it: Type db.students.find() again. You will see "age" is now 22.

5. Data Manipulation - Delete
Command: db.<collection_name>.deleteOne(<filter>)

db.students.deleteOne({ name: "Sunny" }) => the document in which name is sunny will be deleted
{ "acknowledged": true, "deletedCount": 1 } => output

6. Drop Collection & Drop Database
A. Drop Collection This removes the "students" tab completely. Type this:
db.students.drop() => output => true


B. Drop Database This removes the "college" database completely. Type this:
db.dropDatabase() => output => { "ok": 1, "dropped": "college" }

LET'S GO DEEPER INTO EACH OF THE FOUR MAIN OPERATIONS: INSERT, READ(FIND), UPDATE AND DELETE 

---- 1. deep dive: insert(creation) => you allready know 'insertOne'. but in real backend, you often need to create 100 users at once, or you need to understand exactly what creates a document

A. Bulk insertion (insertMany) => if you have an array of data (like a list of students from a CSV file), using 'insertOne' inside a loop is slow. 'insertMany' is optimized to send them all in one network packet.

Try this Command

db.students.insertMany([
  { name: "Rahul", age: 22, marks: 90, city: "Mumbai" },
  { name: "Priya", age: 20, marks: 85, city: "Delhi" },
  { name: "Amit", age: 23, marks: 70, city: "Delhi" },
  { name: "Neha", age: 21, marks: 95, city: "Pune" }
])

Output => 

{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId('692aa6951a2da23da963b112'),
    '1': ObjectId('692aa6951a2da23da963b113'),
    '2': ObjectId('692aa6951a2da23da963b114'),
    '3': ObjectId('692aa6951a2da23da963b115')
  }
}

B. The _id Field (what is it really) => when you insert a document. if you don't provide and '_id', MongoDB generates an 'ObjectId'. it is not random. it is 12-byte hexadecimal value containing.

1. Timestamp(4 bytes) => when it was created.(you can actually Extract the creation date from the ID!).
2. Machine ID(5 bytes) => unique to the server running the database.
3. counter(3 bytes) => A running number to insure uniqueness.

--- 2. Deep Dive: Find(Reading and filtering) ---

db.collection.find() => by itself returns everything. real powers comes from Query operators.
These are the specil keywords that start with $ used to filter data.

A. Comparision operator => instead of finding exacty matches (age:20), you can find ranges.

. $gt (Greater than) / $gte(Greater than or Equal): "find students with marks greater than 80."

db.students.find({ marks: { $gt: 80 } })

. $lt (Less Than) / $lte (Less Than or Equal): "Find students younger than 22."

db.students.find({ marks: { $lt: 22 } })

. $in (In Array): "Find students who live in EITHER Delhi OR Mumbai."

db.students.find({ city : {$in : ["Delhi", "Mumbai"]}})

B. LOGICAL OPERATORS => you can combine multiple conditions.

. $and : (implicit in MongoDB, but can be explicit). "let's find students age more than or equal to 22 AND city has to be "Mumbai" or "Delhi"

db.students.find({ city : {$in : ["Delhi", "Mumbai"]}, age : {$gte : 22}});

. $or : "Find students who makrs greter that 85 or lives in delhi"

db.students.find(
  {
    $or : [
      { marks : { $gt : 85}}, 
      { city : "Delhi"}
    ]
  }
)

C. PROJECTION (SELECTING FIELDS)
=> in a real app, your user document might have 50 fields(password, history, hobbies, logs). but your frontend only needs their 'name' and 'city'. sending the whole document wastes bandwith. 
we use 'Projection'(The second Argument in 'find') to include (1) or exclude (0) fields.

// return ONLY 'name' and 'city' hide the _id
db.students.find({}, { name : 1, city : 1, _id: 0});

[
  { name: 'Rahul', city: 'Mumbai' },
  { name: 'Priya', city: 'Delhi' },
  { name: 'Amit', city: 'Delhi' },
  { name: 'Neha', city: 'Pune' },
  { name: 'Sunny', city: 'jalandhar' }
]

db.students.find({}, {city : 1, marks : 1}); => id will also come if we want to hide id then we have to inclue '_id : 0'

[
  {
    _id: ObjectId('692dd17ba70068bc4863b112'),
    marks: 90,
    city: 'Mumbai'
  },
  {
    _id: ObjectId('692dd17ba70068bc4863b113'),
    marks: 85,
    city: 'Delhi'
  },
  {
    _id: ObjectId('692dd17ba70068bc4863b114'),
    marks: 70,
    city: 'Delhi'
  },
  {
    _id: ObjectId('692dd17ba70068bc4863b115'),
    marks: 95,
    city: 'Pune'
  },
  {
    _id: ObjectId('692dd48ba70068bc4863b116'),
    marks: 80,
    city: 'jalandhar'
  }
]

3. Deep Dive : UPDATE(MODIFICATION)
=> 'updateOne' requires two parts: the Filter (who to change) and the Update Operator(how to change it) if you don't use an operator, you might accidentally replace the entire document.

A. specific Field Operators 
. $set => Updates seperate fields, leaves others alone.

// Change Amit's city to 'Bangalore'
db.students.updateOne({ name: "Amit" }, { $set: { city: "Bangalore" } })

. $inc(increment): Useful for counters like "views", "likes", or "age". you don't need to read the current value first; the database does the math.

// Add 2 bonus marks to Rahul 
db.students.updateOne({ name : "Rahul" }, { $inc: {marks: 2}});

. $rename => renames a field(column) itself.
db.students.updateMany({}, { $rename: {"marks": "score"}});

. $unset => deletes a field from a document completely
// Remove the 'age' field from Neha
db.students.updateOne({name : "Neha"}, {$unset : {age : ""}});

B. upsert (Update or insert) => this is a very common requirement. "Update this user if they exist, create them." instead of writing an 'if/else' in your code, you can use the 'upsert : true' option

db.students.updateOne(
    { name: "Vikram" },         // Look for Vikram
    { $set: { marks: 88 } },    // Set marks to 88
    { upsert: true }            // Option: If not found, CREATE him.
)

=> Since "Vikram" didn't exist before, MongoDB creates a new document for him.

db.students.updateOne(
  {name : "Sunny"}, 
  {$set : {score: 99}},
  {upsert: true}
)

=> since "Sunny" exist before. MongoDB will update marks of "sunny"

4. Deep dive: Delete => be careful here
. deleteOne(filter) => deletes the first document that matches
. deleteOne(filter) => deletes every documents that matches

example: "delete all the students who scored less than 85"
db.students.deleteMany({ score : {$lt : 85}});