if you want to be a top-tier Full stack developer, knowing how to save() and find() is meaningless. Any junior can do that.

To master Mongoose, you need to understand where to put your 'Business Logic'. Beginners put everthing in route handler(controllers). professional put logic inside the 'Schema' using Validtors, Methods and Virtuals.

Here is part1 of Advanced Mongoose: Building "Smart" Models.

1. Advanced Validation & Constraints
=> in real app, you never trust user data. you don't just check if a field exists; you sanitize and validate it strictly

Key Concepts:
. Built in Validators: min, max, enum(enumerated lists), match (Regex).
. Sanitizers: trim(remove whitespaces), lowercase (converts input)
. Custom Validators: Writing your own JS function to check data.

--- THE PROFESSIONAL CODE STRUCTURE ---
create a file called pro-user-model.js, look at how detailed this Schema is compared to the previous one.


pro-user-model.js
code->

const mongoose = require('mongoose');

// define the schema
const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: [true, "Username is required"],  // Custom error message
        trim: true,  // '   John     ' => 'John'
        minLength: 3,
        maxLength: 20,
    }, 
    email: {
        type: String,
        required: true,
        unique: true, // Ensures no duplicate emails in DB
        lowercase: true,  // User23@gmail.com => user23@gmail.com
        // Regex to validate email format
        match: [/^\S+@\S+\.\S+$/, 'Please use a valid email address']
    },
    role: {
        type: String,
        // ENUM: The value MUST be one of these strings.
        enum: ['user', 'admin', 'guide'],
        default: 'user'
    },
    age: {
        type: Number,
        // CUSTOM VALIDATOR
        validate: {
            validator: function(value){
                // Return true if valid, false if invalid
                return value % 2 == 0;
            },
            message: props => `${props.value} is not an even Number! (We only accept even ages for weird reason)`
        }
    },
    tags: {
        type: [String], // Array of strings
        validate: {
            validator: function(v){
                return v && v.length > 0; // Array must not be empty
            },
            message: 'A user must have atleast one tag.'
        }
    }
}, {
    timestamps: true // Automatically adds 'createdAt' and 'updatedAt'
});

// method to check if user is a "Senior Admin"
userSchema.methods.isSeniorAdmin = function(){
    // 'this' refers to the spacific user document
    return this.role == 'admin' && this.age > 30;
}

// method to generate a formal greeting
userSchema.methods.sayHello = function() {
    return `Greetings, ${this.username}. Your role is ${this.role}.`;
}

// Stiatic method to find all admins
userSchema.statics.findAllAdmins = function(){
    // 'this' refers to the User Mode
    return this.find({role: 'admin'});
}

// create model
const User = mongoose.model('User', userSchema);
module.exports = User;

code ended here....

2. Instance Methods(Logic on the document)
=> this is a massive concept. instead of Writing logic in your main code like this: 
// BAD: Logic is exposed in your controller
if (user.role === 'admin' && user.age > 20) { ... }

// GOOD: Logic is hidden inside the User model
if (user.isSeniorAdmin()) { ... }

3. statics (Logic on the model)
=> Instance methods act on one user. Static method act on the whole collection. these These are great for complex lookups.

// Static method to find all admins
userSchema.statics.findAllAdmins = function() {
    // 'this' refers to the User Model
    return this.find({ role: 'admin' });
};

4. Virtual (Fake properties)
=> sometimes you want a property in your output that isn't actually saved in the database.

. example => your store 'firstName' and 'lastName', but fontend wants 'fullName'. Do not save fullName in the DB in the DB (that's is reductant data) compute it on the fly.

userSchema.Virtual('fullName').get(function() {
    return `${this.firstName} ${this.lastName}`;
});

5. Running the "Pro" code
here is how you actually run and test these Advanced features. create a file test-pro-model.js

test-pro-mode.js
code ->

const mongoose = require('mongoose');
const User = require('./pro-user-model'); // Import your fancy Model

mongoose.connect('mongodb://localhost:27017/proDB')
    .then(() => console.log("Connected"))
    .catch(err => console.log(err))

async function run(){
    try{
        // 1. create a user (trying to break our rules)
        // if you change the 'role' to 'superuser', it will fail (Enum check)
        // if you change 'age' to 21, it will fail (custom check).
        const user = await User.create({
            username: "    TechLead    ", // will be treamed
            email: "Lead@Code.com", // will be lowercased
            role: "admin",
            age: 32,
            tags: ["developer", "backend"]
        });

        console.log("--- Created User ---");
        console.log(user);
        // Notice: 'createAt' exists automatically

        //2. Test Instance method
        console.log("\n--- Testing Methods ---");
        console.log("Is Senior Admin?", user.isSeniorAdmin()); // should be true
        console.log(user.sayHello());

        // 3. Test Static method
        console.log("\n--- Testing Statics ---");
        const findAllAdmins = await User.findAllAdmins();
        console.log(`Found ${findAllAdmins.length} admins.`);

    } catch (e) {
        // this catches our validation errors
        console.log("VALIDATION ERROR:", e.message);
    }
}

run();

--- code ended here---

--- summary of pro concepts ---
1. Validations => keep your database clean. if the data is garbage, reject it at the door(the Schema)
2. Encapsulation => Don't write logic in your controllers. if the logic is about user, put it inside the userSchema (using methods).
3. timestamps => always use {timestamps: true}. it solves so many debugging headaches later.

What is next?
We have covered "Smart Models." But we are still dealing with single collections.

The hardest part of MongoDB for SQL developers is Relationships.

How do you link a User to their Posts?

Do you put the Post ID in the User?

Or the User ID in the Post? (This is a huge architectural decision).

How do you use .populate()?