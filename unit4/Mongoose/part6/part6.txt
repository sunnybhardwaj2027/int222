---------- PROFESSIONAL ARCHITECTURE (MVC) ----------

Right now, your server.js works, but it's fragile. if you add 10 more API routes, that file will become 500 lines of mess.

In c++, you don't write your entire program in main.cpp. you use header files(.h) and implementation files(.cpp). In React, you don't put every button and form in App.jsx, you make components.

In Backend, we use the MVC pattern(Models, view, controllers). Since we are building an API(no HTML 'view'), we focus on models, controllers and routes.

1. The Folder structure 
=> Delete you old code mentally. we are organizing your project folders like this:

/my-backend
  ├── /models         <-- Database Schemas (The "Blueprint")
  ├── /controllers    <-- The Logic (The "Brain")
  ├── /routes         <-- The URL paths (The "Menu")
  ├── server.js       <-- Entry Point (The "Manager")
  └── package.json

2. step-by-step Refactoring 
=> let's take the logic we wrote in part 5 and split it into these folders.

Step A: The model(models/User.js)
=> This file only cares about what that data looks like.

--- code ---

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema(
    {
        username: {
            type: String,
            required: true,
        },
        email: {
            type: String,
            required: true,
            unique: true,
        }
    }
)

module.exports = mongoose.model('User', userSchema);

--- code ended ---

Step B: the Controller (controllers/usercontroller.js)

This file handles the logic. it Receives the Request( req ) and decides what Response ( res ) to send. it talks to the model.

--- code ---

const User = require('../models/User');

// Logic to create a user
const createUser = async (req, res) => {
    try {
        const newUser = await User.create(req.body);
        res.status(201).json({ message: "Success", user: newUser });
    } catch (err) {
        res.status(500).json({ message: "Error", error: err.message});
    }
};

// Logic to get all users
const getUsers = async (req, res) => {
    try {
        const users = await User.find(); // Mongoose method to find all 
        res.status(200).json(users);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
};

// Export these functions so routes can use them
module.exports = { createUser, getUsers };

--- code ended ---

Step C: The Routes (routes/userRoutes.js)

=> This file maps the URL to the controller. it acts like a traffic sign.

--- code ---

const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');

// when a POST request hits '/', run the createUser function
router.post('/', userController.createUser);

// when a GET request hits '/', run the getUsers function
router.post('/', userController.getUsers);

module.exports = router;

--- code ended ---

const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');

// when a POST request hits '/', run the createUser function
router.post('/', userController.createUser);

// when a GET request hits '/', run the getUsers function
router.post('/', userController.getUsers);

module.exports = router;

Step D: (server.js)

=> Now, look how clean your main file becomes. it just sets up the configuration and imports the routes.

--- code ---

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const userRoutes = require('./routes/userRoutes');

const app = express();

// Middleware
app.use(express.json());
app.use(cors());

// Database Connect
mongoose.connect('mongodb://localhost:27017/myFirstApiDB')
    .then(() => console.log("DB connected"))
    .catch(err => console.log(err));

// useRoutes
// this says: "Any URL starting with /api/users, go look at userRoutes"
app.use('api/users', userRoutes);

app.listen(3000, () => console.log("Server running on port 3000"));

--- code ended ---

3. How the Request Flows
    . when your React app sends a POST request to http://localhost:300/api/users:
        1. Server (server.js): Sees the request starts with '/api/users'. it passes the baton to 'userRoutes'
        2. Routes (userRoutes.js): Sees it is POST request to '/'. it points to 'userController.createUser'.
        3. controller (userController.js): Runs the logic. it asks the 'User' model to save data.
        4. Model (User.js): validates the data against the Schema and talks to MongoDB.
        5. Response: The Controller sends the JSON back to React.

Why this makes you a "Good Developer"
    1. Scalability: if you want to add a "Products" feature later, you just create productModel.js, productController.js and productRoutes.js. you don't touch your existing code.
    2. Debugging: if the database Schema is wrong, you know exactly where to look (models). if the logic is worng, you check controllers. you don't hunt through a 2000-line file.
    3. Teamwork: One developer can work on the User routes while another works on Product routes without creating "merge-conflicts" in GitHub

what's Next ?
    Now you have a professional structure and a React frontend connected to it. But right now, anyone can create a user with any name

    Real apps need CRUD (Create, Read, update, Delete) and robust data validation.
    