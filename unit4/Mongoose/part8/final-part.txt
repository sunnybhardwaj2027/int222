----------------------------- FINAL PART ---------------------------------

THIS PART COVERS:

1. Robust Input Validation (The "Bouncer")
    . Right now, if a user sends an email as "hello-world", Mongose might catch it, or it might save it. We need a library like 'joi' or 'express-validator' to stop bad data before it even reaches your controller.

    . why: Keeps your database clean and prevent crashes.

2. Authentication & Security (The "ID Card")
    . This is the biggest missing piece
        . Hashing: Storing Passwords as '12345' is a Security crime. we need 'bcrypt' to turn them into '$2b$10$X7...'
        . JWT (JSON web token): how does the server know "User A" is logged in ? we issue them a digital token
        .Protected routes: Creating middleware so that only logged-in users can post, and only Admins can delete.

3. Advanced Querying( pagination & Filtering )
    . Currently, User.find() fetches every single user.

        . the Problem: if an app has 10,000 products, loading the homepage will crash the browser
        . The fix: We need to implement pagination (?page=1&limit=10), sorting (?sort=-price), and Filtering(?category=village-products)
        
4. File uploads (Multer)
    . apps needs products image. you can't store image MongoDB directly (it's too slow).
        . The Solution: We use a library called 'multer' to accept image uploads and store them in the cloud (like cloudinary or AWS 33)

5. Global Error Handling
    . Right now, you wirte 'try/catch' in every single controller function. That is repetive code (DRY violation).
        . The Fix : We create a centralized Error Handler that catches errors from anywhere in the app and formats them nicely.

----------------------- MIDDLEWARE & VALIDATION (THE BOUNCER) ----------------------

Rigth now, you API is like a club with no bouncer. Anyone can walk in with fake IDs(bad data) and cause trouble.

if a frontend dev sends this JSON:
    {
      "username": "",
        "email": "not-an-email"
    }
=> your current code tries to save it. MongoDB might throw an error, but we want to catch this before it even touches our database logic.

=> we will use a library called 'express-validator'. it is the industry standard for Express.

1. INSTALLATION
    => In your backend terminal: 
        => npm install express-validator

2. CREATE THE VALIDATOR MIDDLEWARE
    => create a new folder called middleware and a file named 'userValidator.js'

*** we are going to define a set of rules (checks) for creating a user ***

code :- ./middleware/userValidator.js

const { body, validationResult } = require('express-validator');

// 1. define the rules

const validateCreateUser = [
    // Check Username: Must not be empty
    body('username')
        .trim() // Remove 'whitespaces' "    John     " => "John"
        .notEmpty().withMessage('Username is required')
        .isLength({ min: 3 }).withMessage('Username must be at least 3 chars long'),

    // Check email: Must be a valid email format
    body('email')
        .isEmail().withMessage('Must be a valid email address')
        .normalizeEmail(), // Sanitize email (conver to lowecase)

    // Check password (if you had one):
    // body('password').isLength({ min: 6 }).withMessage('Password too Short')

];

// 2. middleware function that checks the results.
const handleValidationErrors = (req, res, next) => {
    // check if the rules above found any erros
    const errors = validationResult(req);

    // if there ARE erros, stop the requrest here. Don't call next().
    if(!errors.isEmpty()){
        return res.status(400).json({
            message: "Validation Failed",
            errors: errors.array()
        });
    }

    // if no Errors, let the request pass to the controller
    next();
};

module.exports = { validateCreateUser, handleValidationErrors };

--- code ended ---

3. apply the bouncer to the routes

Open routes/userRoute.js
=> we will inject our new middleware between the path ('/') and the controller ( createUser ).

---- code ---

const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');

// Import the bouncer 
const { validateCreateUser, handleValidationErrors } = require('../middleware/userValidator');

// MODIFY THE POST ROUTE
// The request goes: Route -> Rules -> ErrorHandler -> Controller
router.post(
    '/',
    validateCreateUser, // Step 1: Run the checks 
    handleValidationErrors, // Step 2: check if checks passed
    userController.createUser // Step 3: Run logic (only if step 2 passed)
);

router.get('/', userController.getUsers);
router.put('/:id', userController.updateUser);
router.delete('/:id', userController.deleteUser);

module.exports = router;


--- code ended ---

4. Test it Bad request

if you try to send this data via postman or your react form now :

{
    "username": "Jo", 
    "email": "bad-email" 
}

Your server Response (400 Bad Request)

{
    "message": "Validation Failed",
    "errors": [
        {
            "msg": "Username must be at least 3 chars long",
            "path": "username",
            "value": "Jo"
        },
        {
            "msg": "Must be a valid email address",
            "path": "email",
            "value": "bad-email"
        }
    ]
}

NOtice ? The Controller never ran. The database was never bothered. This saves server resources and keeps you data clean.

why this makes you a "Good develper" 

1. Sanitization: The .trim() and .normalizeEmail() functions automatically clean up user input. if a user accidentally types "   John@gmail.com  ", you database saves "john@gmail.com".

2. standardized errors: the frontend team loves this. They get an array of errors (errors : []) that they can easily map over and display under each form input field.

3, Security: This prevents basic injection attacks where people try to send weird scripts instead of emails.



------------------- AUTHENTICATION (THE "ID CARD") ------------------------

=> this is the most complex but most important part of backend development. For any app, you need to distinguish between customer buying something and admin adding new products.

we need two technologies: 
    1. Bcrypt: To lock the passwords safely
    2. JWT (JSON web token): To give the user a digital "ID Badge" after they log in.

1. INSTALLATION
    . we need two new package
        . bcrypjs: A pure javascript version of bcrypt(easier to install on windows)
        . jsonwebtoken: To create the tokens.

        .In your terminal: 
            npm install bcrypjs jsonwebtoken

