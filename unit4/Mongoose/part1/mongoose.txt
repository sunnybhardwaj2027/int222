INTRODUCTION TO MONGOOSE

This is how professional Node.js interact with MongoDB. while the "Native Driver"(which we just used) is powerful, it is also "dumb". it let's you save any garbage data(like a string for age).

Mongoose is an ODM(object data modelling) library. it acts as bodyguard for your database. it enforce rules(Schemas) so your data stays clean and optimized.

1. installation

we need to install mongoose package.
1. open your terminal in your project folder.
npm install mongoose

2. Core concepts: Schemas and Models
Mongoose introduces two new concepts that didn't exist in the native Driver

A. Schemas(The blueprint) => a Schema is a rulebook. it defines the structure of your documents.

. "A user must have a 'name' (string)"
. "A user must have an 'email' (string) ans it is required"
. "A user must have an 'age' (number)"

B. Model(The construtor) => A Model is a fancy javascript class that mongoose creates based on your schema.

. You use the MODEL to interact with database.
. Student.find() --> uses model to search.
. new Student() --> uses the Model to create a new document.

3. implementing Mongoose(complete code) => let's rebuild our student database logic, but this time using Mongoose. you will see how much cleaner and safer it is.

mogoose-basics.js

// 1. import mongoose
const mongoose = require('mongoose');

// 2. connection url (same as before, but with the DB name included)
const url = 'mongodb://localhost:27017/college';

async function main(){
    try {
        // --- STEP A: CONNECT ---
        console.log('Connecting to MongoDB...');
        // Mongoose handles connection buffering(it waits until connected)
        await mongoose.connect(url);
        console.log('Connected Succesfully');

        // --- STEP B: DEFINE SCHEMA (THE RULES) ---
        // this is where Mongoose shines. we define strict types.
        const studentSchema = new mongoose.Schema({
            name : {
                type : String, 
                required : true, // must have a name
                cast: false    
            }, 
            age : { type : Number, min : 18}, // must be 18+
            course : String, // short syntax
            isEnrolled: { type : Boolean, default : true} // default value
        });

        // --- STEP C: CREATE MODEL (THE TOOL) ---
        // 'Student' is the name of the model.
        // Mongoose automatically looks for the collection named 'students' (lowercase + plural)

        const Student = mongoose.model('Student', studentSchema);

        // --- STEP D: CRUD OPERATIONS ---

        //1. CREATE(SAVE)
        console.log('\n1. Creating a new Student...');
        // we create a new instance of the model
        const newStudent = new Student ({
            name : "Sanya",
            age : 20,
            course : "B.Tech"
        });
        // we call .save() to write it to the database
        const saveDoc = await newStudent.save();
        console.log('Saved:', saveDoc);

        //2. FIND(FIND)
        console.log('\n2. Finding the Student...');
        // Mongoose gives us the simpler methods. No need for .toArray()
        const foundStudent = await Student.findOne({name:"Sanya"});
        console.log('Found:', foundStudent);

        //3. UPDATE
        console.log('\n3. Updating Course...');
        // Model.UpdateOne(filter, update)
        const updateResult = await Student.updateOne(
            {name : "Sanya"},
            {$set : {course : "M.Tech"}}
        );

        console.log('Modified Count:', updateResult.modifiedCount);

        //4. DELETE
        console.log('\n4. Deleting the Student...');
        const deleteResult = await Student.deleteOne( { name : "Sanya"});
        console.log('Deleted Count:', deleteResult.deletedCount);
    } catch (err) {
        console.error('Error:', err);
    } finally {
        //--- STEP E: CLOSE CONNECTION---
        await mongoose.connection.close();
        console.log('\nConnection closed');
    }
}

main();

/*

output --> 

Connecting to MongoDB...
Connected Succesfully

1. Creating a new Student...
Saved: {
  name: 'Sanya',
  age: 20,
  course: 'B.Tech',
  isEnrolled: true,
  _id: new ObjectId('6930d2ad91874b516338b475'),
  __v: 0
}

2. Finding the Student...
Found: {
  _id: new ObjectId('6930d2ad91874b516338b475'),
  name: 'Sanya',
  age: 20,
  course: 'B.Tech',
  isEnrolled: true,
  __v: 0
}

3. Updating Course...
Modified Count: 1

4. Deleting the Student...
Deleted Count: 1

Connection closed

*/

4. why is this better?

Try this experiment(mentally or in code). if you tried to save this with the 'Native Driver', it would work: { name: "Sanya", age : "TWENTY" }

if you try to save this with Mongoose (using the code above), it will fail immediately with an error: 'ValidationError: Student validation failded: age: Cast to Number failed for valie "TWENTY"

This protection is why 99% of Node.js developers use Mongoose.


